---
id: rendering-implementation
title: React Native Rendering Implementation
---

In the previous render system of React Native, the _React Shadow Tree_, _Layout System_, and _View Flattening_ algorithm were implemented once for each platform. The Fabric render system was designed to be a cross-platform solution which enables the implementation of all features to be shared across all platforms. The React Native team intends to incorporate an animation system into the render system and also extend the Fabric render system to new platforms such as Windows, PlayStation, and more.

Leveraging C++ for the core render system introduces several advantages. A single implementation reduces the cost of development and maintenance. It improves the performance of creating _React Shadow Trees_ and layout calculation because the overhead of integrating Yoga with Fabric is minimized on Android (i.e. no more JNI for Yoga). Finally, the memory footprint of each _React Shadow Node_ is smaller in C++ than it would be if allocated from Kotlin or Swift.
The team is also leveraging C++ features that enforce immutability to ensure there are no issues related to concurrent access to shared but not protected resources.

It is important to recognize that Fabric for Android still incurs the cost of JNI for two primary use cases:

1. Layout calculation of complex views (e.g. `Text`, `TextInput`, etc.) requires sending props over JNI.
2. The mount phase requires sending mutation operations over JNI.

The team is exploring replacing `ReadableMap` with a new mechanism to serialize data using `ByteBuffer` to reduce overhead of JNI. Our goal is to reduce overhead of JNI by 35–50%.

Fabric provides two sides of its C++ APIs (i) to communicate with React and (ii) to communicate with the host platform. From one side React communicates with Fabric to **render** a React Tree and to “listen” for **events** (e.g. onLayout, onKeyPress, touch, etc). On the other side, Fabric communicates with the host platform to mount host views on the screen (create, insert, update or delete of host views) and it listens for **events** that are generated by the user on the host platform.
[Image: image.png]

## **View Flattening**

The React API is designed to be declarative and reusable through composition; this is great for product developers because they can focus on what they want to render instead of how to render on the screen. However, in practice, these qualities of the API lead to the creation of deep React Element Trees, where a large majority of their Nodes only affect the layout of a View and don’t render anything on the screen, we call these types of nodes “Layout-Only” Nodes.

Conceptually, each of the Nodes of the _React Element Tree_ have a 1-1 relationship with a view on the screen, therefore rendering a deep React Element Tree that is composed by a big amount of “Layout-Only” Node leads to poor performance during rendering.

Here is an example of a common use case that is affected by the cost of "Layout Only" views. Imagine you want to render an image and a title that is handled by the `TitleComponent`, and you include this component as a child of the `ContainerComponent` that has some margin styles. After decomposing the components, the React code would look like this:

```
function MyComponent() {
  return (
    <View>                          // ReactAppComponent
      <View style={{margin: 10}} /> // ContainerComponent
        <View style={{margin: 10}}> // TitleComponent
          <Image {...} />
          <Text {...}>This is a title</Text>
        </View>
      </View>
    </View>
  );
}
```

As part of the render process React Native will produce the following trees:
[Image: image.png]Note that the Views (2) and (3) are “Layout Only” views, because they are rendered on the screen but they only render a margin of 10 px on top of their children.

To improve the performance of these types of React Element Trees, Fabric implements a View Flattening mechanism that “merges or flattens” these types of Nodes, reducing the depth of host view hierarchy that is rendered on the screen. This algorithm takes into consideration props like: _margin_, _padding_, _backgroundColor_, _opacity_, etc.

The View Flattening algorithm is integrated by design as part of the diffing stage of the render of Fabric, which means that we don’t use extra CPU cycles to optimize the React Element Tree flattening these types of views. As the rest of the core, the View flattening algorithm is implemented in C++ and its benefits are shared by default on all supported platforms.

In the case of the previous example, the Views (2) and (3) would be flattened as part of the “diffing algorithm” and as a result their styles will be merged into the View (1):
[Image: image.png]It is important to note that this optimization allows Fabric to avoid the creation and render of two host views and from the user’s perspective there are no visible changes on the screen.

## **Threading Model**

The phases of the Render process of Fabric can be executed on different threads. Fabric uses three different threads.

- UI (often called main) thread. The only thread that can manipulate host views.
- JavaScript thread. This is where React’s render phase is executed.
- Background thread. Thread dedicated to layout.

Let’s review the supported scenarios of execution for each phase:
[Image: image.png]

- **Render in a Background Thread**: this is the most common scenario where most of the Render pipeline happens on JavaScript and Background thread.

[Image: Case 1.jpg]

- **Render in the UI Thread**: when there is a high priority event on the UI Thread, Fabric is able to execute all the render pipeline synchronously on the UI thread.

[Image: Case 2.jpg]

- **Default or continuous event interruption**: This scenario shows the interruption of the render phase by a low priority event in the UI thread. React and Fabric are able to interrupt the Render phase and merge its state with a low priority event that is executed on the UI thread. In this case the render process continues executing in the background thread.

[Image: Case 4.jpg]

- **Discrete event interruption**: The render phase is interruptible. This scenario shows the interruption of the render phase by a high priority event in the UI thread. React and Fabric are able to interrupt the render phase and merge its state with a high priority event that was executed on the UI thread. The render phase executes synchronously on the UI thread.

[Image: Case 3.jpg]

- **Background thread batches updates from JavaScript: \*\*** \*\*Before background thread dispatches update to UI thread, it checks if a newer update hasn’t come in from JavaScript. This way, Fabric doesn’t render stale state when it knows a newer state is coming it.

[Image: Case 5.jpg]

- **C++ State update: \*\*** \*\*Update originating on UI thread and skips rendering phase. See [Fabric State Updates](rendering#fabric-state-updates) for more details.

[Image: State update.jpg]
Fabric is designed to be thread safe. At a high level thread safety is guaranteed by using immutable data structures in the internals of the framework (actually enforced by C++ “const correctness” feature). This means that every update in React needs to create or clone new objects in Fabric instead of updating data structures. This allows the framework to expose thread safe and synchronous APIs to React.

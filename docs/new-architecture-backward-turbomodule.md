---
id: new-architecture-backward-compatible-turbomodule
title: Create a Backward Compatible Turbomodule
---

import NewArchitectureWarning from './\_markdown-new-architecture-warning.mdx';
import M1Cocoapods from './\_markdown-m1-cocoapods.mdx';

<NewArchitectureWarning/>

This guide describes how to create a Turbomodule, by keeping it backward compatibile with the old Architecture. To achieve this result, we first need to create a Native Module and then to build a Turbomodule on top of it.

To learn more about Native Modules, go [here](https://reactnative.dev/docs/native-modules-intro)

To learn more about Turbomodule, check this deep dive. <!-- TurboModule Deep dive needs to be written -->

## Who Is This Guide For?

This guide is written with library developers in mind. We would like to provide a guide to create a module that work with both architectures, sharing as much code as possible.

Also, we would like to show how to make sure that bits required by the New Architecture are installed only when the app is build for it, while keeping it lean for the old one.

The guide can also be useful for developers that want to write their first module but that don't know from where to start. They would be able to follow the guide step by step, reaching a working project that they can customize.

If you are interested in creating a Turbomodule, you can skip this part and directly go [here](#create-the-turbomodule). Consider that a Turbomodule is built on top of a Native Module, so you would probably need to look at the [Implement the iOS Code](#implement-the-ios-code) section at some point.

## Create the Native Module

This section and the following are a practical guides to create a module that is backward compatible. We are not diving deep into what can be done with Native Modules. For more informations on that topic, have a look [here](native-modules-intro).

### Creating the Structure

We have two alternatives to create the basic structure for our module.

1. Using the React Native CLI.
2. Manually.

#### React Native CLI

To create a turbomodule with the React Native CLI, run the following command:

```sh
npx create-react-native-library <name-of-the-library>
```

Follow the questions the CLI asks and, once the process is done, it will create a folder structure completed with an example app, typescript configuration and much more. The sample structure is shown in the following image:

<figure>
  <img src="docs/assets/Turbomodules/NpxLibFolderStructure.png" />
  <figcaption>The folder structure generated by the React Native CLI</figcaption>
</figure>

This is a good starting point, but remember to double check what will be published if you keep this setup. Moreover, the `TypeScript` support for the new architecture is still in beta, so you won't be able to use it for the Turbomodule sections.

#### Manually

The second approach is to create a similar structure manually. What we need to start is a folder named `example-library` and a `package.json` file with the following content:

```json title="package.json"
{
  "name": "example-library",
  "version": "0.0.1",
  "description": "Showcase Turbomodule with backward compatibility ",
  "react-native": "src/index",
  "source": "src/index",
  "files": [
    "src",
    "android",
    "ios",
    "example-library.podspec",
    "!android/build",
    "!ios/build",
    "!**/__tests__",
    "!**/__fixtures__",
    "!**/__mocks__"
  ],
  "keywords": ["react-native", "ios", "android"],
  "repository": "https://github.com/<your_github_handle>/example-library",
  "author": "<Your Name> <your_email@your_provider.com> (https://github.com/<your_github_handle>)",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/<your_github_handle>/example-library/issues"
  },
  "homepage": "https://github.com/<your_github_handle>/example-library#readme",
  "publishConfig": {
    "registry": "https://registry.npmjs.org/"
  },
  "devDependencies": {},
  "peerDependencies": {
    "react": "*",
    "react-native": "*"
  }
}
```

For sake of simplicity, we will go on with this manual setup, adding files while we work.
Remember to update the `<Your Name>`, `<your_email@your_provider.com>`, and all the `<your_github_handle>` tokens, if you want to follow this approach with your information.

### Create a Testing Environment

To develop a Native Module we would like to test the code we wrote (both the JaveScript code and the native code) and to leverage a compiler with the proper type system for the Native parts. While this comes out of the box when developing an app (we can always build and run the app when we want to check that everything is fine), a library usually does not come with a sample aplication. So, we are going to create one and link our library to it: in this way, whenever we want to test our work, we can run the test application and check that everything is fine.

:::note
If you used the React Native CLI to create the module, you have an application called `example` within you `example-library` folder.
:::

To create a proper test environment, let's navigate to the parent folder of our `example-library` and run the following commands:

```sh
npx react-native init OldArchitectureApp
cd OldArchitectureApp
```

Now, open a new terminal and start Metro by running:

```sh
npx react-native start
```

Go back to previous terminal and run:

```sh
npx react-native run-ios
# Or for Android
npx react-native run-android
```

When all the processes are done, you should see the default React Native application, running on a simulator.
We will update the code of this app to test our Native Module.

### Define the JS Shared Code

The next step is to define how the React Native app will use our module. Native modules are registered using the `NativeModule` object provided by the React Native framework.

For this example, we are going to create a manager that asks the GPS authorization to the user.

As first step, let's create a folder named `src` and an `index.js` file into it. Add the following code into the JS file.

```ts title="index.js"
// @flow
// Import the required objects
import { NativeModules, Platform } from 'react-native';

// Declare an error message, triggered when the Native Module is used but not properly linked.
const LINKING_ERROR =
  'The package "AuthorizationManager" doesn\'t seem to be linked. Make sure: \n\n' +
  Platform.select({
    ios: "- You have run 'pod install'\n",
    default: ''
  }) +
  '- You rebuilt the app after installing the package\n' +
  '- You are not using Expo managed workflow\n';

const manager = NativeModules.AuthorizationManager;
if (manager == null) {
  // Native Module not linked properly.
  throw new Error(LINKING_ERROR);
}

export default manager;
```

:::info
This file uses [`Flow`](https://flow.org/) to work with types.
Types are required for the Turbomodules.
:::

Then, let's create another file called `AuthorizationStatus.js` where we can export the statuses we want to map:

```ts title="AuthorizationStatus.js"
// @flow

// Export the required types.
export type AuthorizationStatus =
  | 'NotDetermined'
  | 'Restricted'
  | 'Denied'
  | 'Authorized'
  | 'AuthorizedAlways'
  | 'AuthorizedWhenInUse';
```

### Implement the iOS Code

Let's create an `ios` folder and then open Xcode. Then, follow these steps:

1. In the Apple's IDE, create a new project.
2. Select the `iOS` tab and the `Static Library` template.
3. Choose a name and a `bundleId`. For this project, let's use `Objective-C` as language.
4. Select the `example-library/ios` folder as destination. Remember to uncheck the `create git repository` option.

Xcode will create a small project with two files: the `ExampleLibrary.h` and the `ExampleLibrary.m`. To stay faithful to Apple convention, let's rename them in `ELExampleLibrary.h` and `ELExampleLibrary.m`.

:::important
The `ExampleLibrary.xcodeproj` must be in the `ios` folder. If you put it into a nested folder, module autolinking won't be able to find it.
:::

:::info
Coding in Xcode without installing the React dependencies could be tricky.
Our suggestion is to use the `OldArchitectureApp` created [here](#create-a-testing-environment) as test bed to have a working iOS environment. Then, remember to copy back to this folder all the code you write in the `OldArchitectureApp` native files.
Once the `ExampleLibrary.xcodeproj` has been created, have a look at the [Test the Native Module](#test-the-native-module) section to see how to install the pod.
:::

Open the `ELExampleLibrary.h` and replace its code with the following:

```objective-c title="ELExampleLibrary.h"
#import <React/RCTBridgeModule.h>

@interface ELExampleLibrary : NSObject <RCTBridgeModule>

@end
```

This code imports the `RCTBridgeModule.h` from the React Native library and it declares that the `ELExampleLibrary` will conform to the `RCTBridgeModule` protocol.

Then, open the `ELExampleLibrary.m` and replace the code with the following:

```obj-c title="ELExampleLibrary.m"
#import "ELExampleLibrary.h"

#import <CoreLocation/CLLocationManager.h>

@implementation ELExampleLibrary {
    CLLocationManager *manager;
}

- (instancetype) init {
    self = [super init];
    if(self) {
        manager = [CLLocationManager new];
    }
    return self;
}

+ (BOOL) requiresMainQueueSetup {
    return YES;
}

RCT_EXPORT_MODULE(AuthorizationManager)

- (NSString *)stringStatusFrom:(CLAuthorizationStatus)authStatus {
    switch (authStatus) {
        case kCLAuthorizationStatusDenied:
            return @"Denied";
        case kCLAuthorizationStatusRestricted:
            return @"Restricted";
        case kCLAuthorizationStatusNotDetermined:
            return @"NotDetermined";
        case kCLAuthorizationStatusAuthorizedAlways:
            return @"AuthorizedAlways";
        case kCLAuthorizationStatusAuthorizedWhenInUse:
            return @"AuthorizedWhenInUse";
    }
}

RCT_REMAP_METHOD(getCurrentStatus, getCurrentStatusWithResolver
                 : (RCTPromiseResolveBlock)resolve withRejecter
                 : (RCTPromiseRejectBlock)reject)
{
    CLAuthorizationStatus authStatus = CLLocationManager.authorizationStatus;
    NSString * stringStatus = [self stringStatusFrom:authStatus];
    resolve(stringStatus);
}

RCT_EXPORT_METHOD(askAuthorization)
{
    [manager requestAlwaysAuthorization];
}
```

This code does:

1. Import the proper headers.
1. Declare a private variable to keep a reference to the manager.
1. Initialize the module with a new instance of the manager.
1. Export the module with a custom name.
1. Add a utility method to convert the status in one of the strings we plan to use in JS.
1. Export a method to get the current status.
1. Export a method to request the localization permissions.

For further information about what we can do in iOS with a Native Module, have a look [here](https://reactnative.dev/docs/next/native-modules-ios).

### Implement the Android Code

**TBD**

For further information about what we can do in Android with a Native Module, have a look [here](https://reactnative.dev/docs/next/native-modules-android).

### Test the Native Module

Now we have all our code set up, it's time to test that everything work.

As first thing, let's navigate to the `OldArchitectureApp` we created [here](#create-a-testing-environment). Then, let's run the following command, to add the library as a new dependency:

```sh
yarn add ../example-library
```

Now, on iOS, let's install the pod:

```sh
cd ios && pod install && cd ..
```

If everything goes right, we should see something like this:

```sh
Auto-linking React Native module for target `OldArchitectureApp`: example-library
Analyzing dependencies
Downloading dependencies
Installing example-library (0.1.0)
Generating Pods project
Integrating client project
Pod installation complete! There are 55 dependencies from the Podfile and 45 total pods installed.
```

Let's now open the `App.js` file and update to code to use our new library. Let's replace the code with the following:

```ts title="App.js"
/**
 * @format
 * @flow strict-local
 */

import React from 'react';
import { useEffect, useState } from 'react';
import type { Node } from 'react';
import {
  SafeAreaView,
  StatusBar,
  Text,
  View,
  Button
} from 'react-native';

import type { AuthorizationStatus } from 'example-library/src/AuthorizationStatus';
import AuthorizationManager from 'example-library/src/index';

const App: () => Node = () => {
  const [authorization, setAuthorization] =
    useState<AuthorizationStatus>('NotDetermined');

  useEffect(() => {
    async function setInitialState() {
      const newState =
        await AuthorizationManager.getCurrentStatus();
      setAuthorization(newState);
    }
    setInitialState();
  }, []);

  return (
    <SafeAreaView>
      <StatusBar barStyle="dark-content" />

      <Button
        title="Request Authorization"
        onPress={() => {
          AuthorizationManager.askAuthorization();
        }}
      />

      <Text style={{ marginLeft: 20 }}>
        Current authorization is: {authorization}
      </Text>
    </SafeAreaView>
  );
};

export default App;
```

We can now go back to the terminal and start Metro:

```sh
npx react-native start
```

and then run the app:

```sh
npx react-native run-ios
# Or, for Android
npx react-native run-android
```

After the app launches, we should see the following state in the simulator:

<figure>
  <img src="docs/assets/Turbomodules/OldArchApp.png" />
  <figcaption>The simulator running the app</figcaption>
</figure>

But, if we tap on the button, nothing happens. That's because the `Core Location` system requires some keys in the plist. Let's do the following:

1. Open the `ios/OldArchitectureApp.xcworkspace`.
1. Select the project in the project navigator.
1. Select the info tab.
1. Scroll down and add the following two keys:
   - `NSLocationWhenInUseUsageDescription`
   - `NSLocationAlwaysAndWhenInUseUsageDescription`
1. Add any description you want for each of these.

Go back to the terminal and run `npx react-native run-ios` again. At this point, when tapping on the button, you should see this image:

<figure>
  <img src="docs/assets/Turbomodules/OldArchAppAlert.png" />
  <figcaption>The simulator using the new module</figcaption>
</figure>

Congratulation! The Native Module is now correctly connected to your app.
If you now relaunch the app, you should see the status getting updated.

:::warning
This is an example. Don't use this module for your location-based features.
:::

## Create the Turbomodule

Let's now see how to create a Turbomodule. A Turbomodule is defined by a set of JS spec that needs to be typed. For that reason, we are going to use `Flow` dialect. `TypeScript` support is still in beta but we hope to release it soon.

Once we have the JS spec, we can proceed generating the C++ code that bridges the native code with the JS counterpart.

For the final step, we will implement the missing bits in the native code and then we will connect it to JS.

The Turbomodules works only for apps tat enables them. To have more context about what does this means, please refer to [this section](https://reactnative.dev/docs/next/new-architecture-app-modules-ios) of the website.

But first, let's create a testing environment suitable for the new architecture.

### Create the New Architecture Testing Environment

The steps to create a New Architecture testing environment are pretty much the same as [here](#create-a-testing-environment).

There are only two differences. The first one is how we create the app. We will need to run:

```sh
npx react-native init NewArchitectureApp --version next
```

At the moment of writing, the `--version next` allows us to retrive the version `0.68.0-rc3` of React Native, which is the first one that supports the New Architecture out-of-the-box. Any version of React Native greater than or equal to the `0.68.x` will work.

The second difference arrives here, with the pod installation. Instead of running the usual `pod install`, we should run:

```sh
cd ios && RCT_NEW_ARCH_ENABLED=1 pod install && cd ..
```

The `RCT_NEW_ARCH_ENABLED` flag will tell to cocoapods to install all the dependencies required by the New Architecture. As final step, let's start Metro in a different terminal:

```sh
npx react-native start
```

And let's run the app, to make sure that everything works:

```sh
npx react-native run-ios
```

### Adding the JS Spec

Let's now create a new JavaScript file called `NativeAuthorizationManager.js`. Let's populate the file with the following code:

```ts title="NativeAuthorizationManager.js"
// @flow

import type { TurboModule } from 'react-native/Libraries/TurboModule/RCTExport';
import { TurboModuleRegistry } from 'react-native';
import type { AuthorizationStatus } from './AuthorizationStatus';

export interface Spec extends TurboModule {
  // your module methods go here, for example:
  askAuthorization(): void;
  getCurrentStatus(): Promise<AuthorizationStatus>;
}

export default (TurboModuleRegistry.get<Spec>(
  'AuthorizationManager'
): ?Spec);
```

In this snippet, we import all the types that we need. Then, we specify a `Spec` interface extending the `TurboModule` class. Th spec declares two functions: `askAuthorization` and `getCurrentStatus`. As last step, we export the `Spec`.

:::warning
The `Native` prefix is **mandatory** for the codegen to work. The code generation process will look for all the modules with the `Native` prefix and it will extract the specs from there.
:::

### Generate the Code

Now, it is time to generate the code. This process requires three steps:

1. Declare where the JS specs are located in the `package.json` file of the module.
2. Add the Turbomodule to an app.
3. Install the pods (for iOS). <!-- _or_ < Something for Android > -->

#### Declare the JS spec location

Open up the `example-library/package.json` file and add the following object, at the end of the file:

```json title="example-library/package.json"
    "codegenConfig": {
        "libraries": [
        {
            "name": "ELAuthorizationManagerSpec",
            "type": "modules",
            "jsSrcsDir": "src"
        }
    ]
  }
```

The `name` property shows how the spec file will be named in the native code. The `type` property states that we want to generate the code for a Turbomodule. Finally, the `jsSrcsDir` indicates where the specs are located.

####Â Add the Turbomodule to an app
Before adding the Turbomodule to the app, we need to update the `example-library.podspec`. Let's go to the `example-library` folder and open the `example-library.podspec`.

Before the `Pod::Spec.new`, add the following variables:

```ruby title="example-library.podspec"
folly_version = '2021.06.28.00-v2'
folly_compiler_flags = '-DFOLLY_NO_CONFIG -DFOLLY_MOBILE=1 -DFOLLY_USE_LIBCPP=1 -Wno-comma -Wno-shorten-64-to-32'
```

Before the `end` keyword, add the following snippet:

```ruby title="example-library.podspec"
  if ENV['RCT_NEW_ARCH_ENABLED'] == '1' then
    s.compiler_flags = folly_compiler_flags + " -DRCT_NEW_ARCH_ENABLED=1"
    s.pod_target_xcconfig = {
      "HEADER_SEARCH_PATHS" => "\"$(PODS_ROOT)/boost\""
    }

    s.dependency "React-Codegen"
    s.dependency "RCT-Folly", folly_version
    s.dependency "RCTRequired"
    s.dependency "RCTTypeSafety"
    s.dependency "ReactCommon/turbomodule/core"
  end
```

Practically, this snippet adds some configuration and dependencies required by the New Architecture in order to work properly. These are guarded by the `if ENV['RCT_NEW_ARCH_ENABLED'] == '1' then` control statement: when we install the pods for the new architecture, we use the `RCT_NEW_ARCH_ENABLED` flag. By checking that this flag is enabled in the `podspec`, we install these additional dependencies only for that architecture.

Now, we can navigate to the `NewArchitectureApp` and run the usual `yarn add ../example-library` to add the module to the app.

#### Install the pods [iOS]

Finally, we can navigate to the `NewArchitectureApp` folder and run the command:

```sh
cd ios && RCT_NEW_ARCH_ENABLED=1 pod install && cd ..
```

If everything goes well, you should be able to see this lines in the terminal:

```sh
[Codegen] >>>>> Processing ELAuthorizationManagerSpec
[Codegen] Generated schema: /var/folders/b7/5gvyd0914t15w42kwy1k_l600000gn/T/ELAuthorizationManagerSpec1DIhKQ/schema.json
[Codegen] Generated artifacts: /Users/cipolleschi/Exmples/NewArch/ios/build/generated/ios/ELAuthorizationManagerSpec
```

In the `ios` folder of the app, a new folder called `build` should appear. The folder contains all the generated code. Among them, you should find a folder called `ELAuthorizationManagerSpec` which contains two files: `ELAuthorizationManagerSpec.h` and `ELAuthorizationManagerSpec-generated.mm`.

The former is the interface for our type. The latter contains the implementation and the code that connects the native world with the JavaScritp one.

### Update the iOS Code

First, let's rename the `ELExampleLibrary.m` to `ELExampleLibrary.mm` to harness the power of Objective-C++.

Then, let's add the following import to gain access to the generated specs:

```objective-c title="ELExampleLibrary.mm"
#ifdef RCT_NEW_ARCH_ENABLED
#import "ELAuthorizationManagerSpec.h"
#endif
```

The import is guarded by our usual flag, so if the pod are installed for the old architecture, this import is not executed.

Then, let's connect the Turbomodule with the following code:

```c++ title="ELExampleLibrary.mm"
#ifdef RCT_NEW_ARCH_ENABLED
- (std::shared_ptr<facebook::react::TurboModule>)getTurboModule:
    (const facebook::react::ObjCTurboModule::InitParams &)params
{
  return std::make_shared<facebook::react::NativeAuthorizationManagerSpecJSI>(params);
}
#endif
```

This code implements a new function of the Turbomodule architecture that lets React Native create a concrete implementation of the JS specs. Once again, we are guarding that code with the `#ifdef RCT_NEW_ARCH_ENABLED` conditional compilation pragma to avoid to compile it in the old architecture.

Let's build the app to make sure that everything works and that there are no building issues.

:::warning
Changes in Xcode won't be reflected in the right folder. The pod is installed from the `node_modules` folder and not from the proper `example-library` folder.
Once everything builds, remember to copy the code we modified in Xcode to the `example-library/ELExampleLibrary.mm` file in the `example-library` folder.
:::

### Update the Android Code

**TBD**

### Test the Turbomodule

The last step of this guide consist in testing that our `NewArchitectureApp` works with our Turbomodule.

We already run some of the steps to connect the module with the app.

Open the `NewArchitectureApp/App.js` and replace the code with the same one we used in the `OldArchitectureApp`.

```ts title="NewArchitectureApp/App.js"
/**
 * @format
 * @flow strict-local
 */

import React from 'react';
import { useState, useEffect } from 'react';
import type { Node } from 'react';
import {
  SafeAreaView,
  StatusBar,
  Text,
  Button
} from 'react-native';

import type { AuthorizationStatus } from 'example-library/src/index';
import AuthorizationManager from 'example-library/src/index';

const App: () => Node = () => {
  const [authorization, setAuthorization] =
    useState<AuthorizationStatus>('NotDetermined');

  useEffect(() => {
    async function setInitialState() {
      const newState =
        await AuthorizationManager.getCurrentStatus();
      setAuthorization(newState);
    }
    setInitialState();
  }, []);

  return (
    <SafeAreaView style={backgroundStyle}>
      <StatusBar
        barStyle={isDarkMode ? 'light-content' : 'dark-content'}
      />
      <Button
        title="Request Authorization"
        onPress={() => {
          AuthorizationManager.askAuthorization();
        }}
      />
      <Text>Current authorization is: {authorization}</Text>
    </SafeAreaView>
  );
};

export default App;
```

Now, the only things we have to change are the `import` statements. Replace the `import type { AuthorizationStatus }` and the `import AuthorizationManager` lines with the following:

```diff title="App.js imports"
- import type { AuthorizationStatus } from 'example-library/src/index';
- import AuthorizationManager from 'example-library/src/index';
+ import type { AuthorizationStatus } from 'example-library/src/AuthorizationStatus';
+ import AuthorizationManager from 'example-library/src/NativeAuthorizationManager';
```

Before running the app, remember to add the required `Info.plist` keys:

- `NSLocationWhenInUseUsageDescription`
- `NSLocationAlwaysAndWhenInUseUsageDescription`

Now, from the terminal, run the `npx react-native run-ios` command to see the app working.

## Summary

To summarise, the steps to create a Turbomodule which is backward compatible with the old architecture, are:

1. Create a Native Module.
2. Create the Turbomodule specs.
3. Make sure that the interfaces of the Native Module and of the Turbomodule are the same.
4. Update the module podspec, using the `ENV["RCT_NEW_ARCH_ENABLED"] == "1"` guard to avoid installing the dependencies in the old architecture.
5. Add the `codegenConfig` to the `package.json` of the module.
6. Add the `#import "<moduleName>Spec.h`, guarded by an `#ifdef RCT_NEW_ARCH_ENABLED` guard.
7. Implement the `getTurboModule` C++ method in the native code, guarded by an `#ifdef RCT_NEW_ARCH_ENABLED` guard.

Then, in your app, you can choose which version of the module to use with the proper `import` in JS and installing the pods with the right command:

- `pod install` for the old architecture.
- `RCT_NEW_ARCH_ENABLED=1 pod install` for the new one.

<M1Cocoapods />
